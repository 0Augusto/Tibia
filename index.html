<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Dano - Tibia</title>
    <style>
        * { box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background: #1e1e2f; color: #ddd; max-width: 1400px; margin: 20px auto; padding: 0 20px; }
        h1, h2, h3 { color: #f0b87b; }
        .container { background: #2a2a3a; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); }
        .guide { background: #1e1e2f; padding: 20px; border-radius: 8px; margin-bottom: 30px; border-left: 5px solid #f0b87b; }
        .guide p { margin: 10px 0; line-height: 1.6; }
        .guide ul { margin: 10px 0 10px 20px; }
        .guide li { margin: 5px 0; }
        .guide code { background: #3a3a4f; padding: 2px 6px; border-radius: 4px; color: #ffd966; }
        .param-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .param-item { display: flex; flex-direction: column; }
        .param-item-row { display: flex; flex-direction: row; align-items: center; gap: 10px; grid-column: span 2; }
        label { font-size: 0.9em; color: #aaa; margin-bottom: 3px; }
        input, select { background: #1e1e2f; border: 1px solid #3a3a4f; color: #fff; padding: 8px; border-radius: 5px; font-size: 1em; }
        input:focus, select:focus { outline: none; border-color: #f0b87b; }
        button { background: #f0b87b; color: #1e1e2f; border: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: 0.2s; margin-right: 10px; margin-bottom: 10px; }
        button:hover { background: #ffd966; }
        .result-box { background: #1e1e2f; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 5px solid #f0b87b; font-size: 1.1em; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; background: #1e1e2f; border-radius: 8px; overflow: hidden; }
        th { background: #3a3a4f; color: #f0b87b; padding: 10px; font-weight: 600; }
        td { padding: 8px; border-bottom: 1px solid #3a3a4f; }
        td input, td select { width: 100%; background: #252535; border: 1px solid #3a3a4f; }
        .action-btn { background: #4a4a6a; color: white; padding: 5px 10px; font-size: 0.9em; margin: 2px; }
        .action-btn:hover { background: #6a6a8a; }
        .total-footer { background: #3a3a4f; padding: 15px; border-radius: 8px; margin-top: 20px; font-size: 1.2em; text-align: center; }
        .credits { text-align: right; margin-top: 10px; color: #888; font-style: italic; }
        .hunt-bar { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .hunt-bar select { flex: 1; min-width: 200px; }
        .admin-note { font-size: 0.9em; color: #f0b87b; margin-left: 10px; }
    </style>
</head>
<body>
<div class="container">
    <h1>‚öîÔ∏è Calculadora de Dano - Tibia</h1>
    
    <!-- Se√ß√£o de instru√ß√µes (homepage) -->
    <div class="guide">
        <h2>üìñ Como preencher os campos para resultados precisos</h2>
        <p>Esta calculadora considera os atributos do seu personagem, o tipo de skill, os charms (Major e Minor) e a quantidade de monstros por hora para estimar o dano total e o sustain (life/mana leech). Siga as orienta√ß√µes abaixo:</p>
        
        <h3>‚öôÔ∏è Par√¢metros do Personagem</h3>
        <ul>
            <li><strong>N√≠vel do Personagem:</strong> Seu level atual. Influencia o dano base.</li>
            <li><strong>Tipo de Skill:</strong> Escolha entre Distance, Magic Level, Fist Fighting, Axe, Club ou Sword. O c√°lculo do dano base se ajusta automaticamente.</li>
            <li><strong>Valor do Skill:</strong> Seu valor de skill (ex: 163 para distance, 120 para magic level, etc.).</li>
            <li><strong>B√¥nus de Equipamento:</strong> Soma de todos os b√¥nus de ataque de equipamentos (ex: 44).</li>
            <li><strong>B√¥nus Diversos:</strong> Outros b√¥nus como Combat Tactics, imbuements que aumentam o ataque, etc. (ex: 38).</li>
            <li><strong>Dano Extra Auto (Shielding):</strong> Valor fixo adicionado ao ataque (ex: 9).</li>
            <li><strong>Chance Cr√≠tico (%):</strong> Percentual de chance de acerto cr√≠tico (ex: 10%).</li>
            <li><strong>Dano Cr√≠tico Extra (%):</strong> Percentual adicional de dano no cr√≠tico (ex: 57,5%).</li>
            <li><strong>Life Leech Base (%):</strong> Soma de todas as fontes de life leech (imbuements, wheel of destiny). Ex: se voc√™ tem 50% de um imbuement e 0,75% da roda, coloque 50,75.</li>
            <li><strong>Mana Leech Base (%):</strong> Soma de todas as fontes de mana leech (imbuements, wheel). Ex: 16% + 0,25% = 16,25.</li>
            <li><strong>Ataques por minuto:</strong> Quantos ataques f√≠sicos voc√™ realiza por minuto (padr√£o: 30 para armas de dist√¢ncia, 25 para armas corpo a corpo, 20 para magia).</li>
        </ul>
        
        <h3>üëæ Monstros da Hunt</h3>
        <ul>
            <li><strong>Nome:</strong> Identifica√ß√£o do monstro (apenas para refer√™ncia).</li>
            <li><strong>Qtd/h:</strong> Quantos monstros voc√™ mata por hora (estimativa).</li>
            <li><strong>Vida:</strong> Pontos de vida do monstro.</li>
            <li><strong>Fraqueza:</strong> Multiplicador de dano elemental (ex: 1.2 para 120%, 1.0 para neutro).</li>
            <li><strong>Major Charm:</strong> Escolha o charm que causa dano. A op√ß√£o <strong>"Normal" n√£o causa dano</strong> (multiplicador 0).</li>
            <li><strong>N√≠vel (Major):</strong> N√≠vel do charm (1, 2 ou 3). As porcentagens s√£o autom√°ticas.</li>
            <li><strong>Minor Charm (Leech):</strong> Escolha um charm de leech: <em>Vampiric Embrace</em> (aumenta life leech), <em>Void's Call</em> (aumenta mana leech), <em>Void Inversion</em> (sem efeito) ou <em>Nenhum</em>.</li>
            <li><strong>N√≠vel (Minor):</strong> N√≠vel do minor charm. As porcentagens de b√¥nus de leech s√£o:
                <ul>
                    <li>Vampiric Embrace: 1,6% (lvl1), 2,4% (lvl2), 3,2% (lvl3)</li>
                    <li>Void's Call: 0,8% (lvl1), 1,2% (lvl2), 1,6% (lvl3)</li>
                    <li>Void Inversion: 0% (qualquer n√≠vel)</li>
                </ul>
            </li>
        </ul>
        
        <p><strong>‚ö†Ô∏è Importante:</strong> Os valores de <code>Life Leech Base</code> e <code>Mana Leech Base</code> devem incluir <strong>todos</strong> os imbuements e b√¥nus da Roda de Habilidades que voc√™ possui. Por exemplo, se voc√™ tem um imbuement de 50% life leech e a roda concede 0,75%, o total √© 50,75%.</p>
        <p>Os minor charms de leech <strong>n√£o causam dano</strong>, apenas aumentam o respectivo leech sobre o dano causado ao monstro (Major + f√≠sico). O b√¥nus √© somado ao leech base no resultado final.</p>
        <p>Para adicionar ou remover monstros, use os bot√µes abaixo da tabela. Os dados s√£o salvos automaticamente no seu navegador.</p>
        <p style="color:#f0b87b;">üîí A exclus√£o de hunts √© restrita ao administrador.</p>
    </div>

    <!-- Gerenciamento de Hunts -->
    <div class="hunt-bar">
        <label for="huntSelect" style="font-weight:bold;">Hunt atual:</label>
        <select id="huntSelect"></select>
        <button id="newHuntBtn">‚ûï Nova</button>
        <button id="renameHuntBtn">‚úèÔ∏è Renomear</button>
        <button id="deleteHuntBtn" style="display:none;">üóëÔ∏è Excluir (admin)</button>
        <span class="admin-note" id="adminIndicator"></span>
    </div>

    <!-- Par√¢metros do personagem com Level e Skill -->
    <div class="param-grid">
        <div class="param-item">
            <label>N√≠vel do Personagem</label>
            <input type="number" id="level" value="107" step="1" min="1">
        </div>
        <div class="param-item-row">
            <div style="flex:1;">
                <label>Tipo de Skill</label>
                <select id="skillType">
                    <option value="distance" selected>Distance</option>
                    <option value="magic">Magic Level</option>
                    <option value="fist">Fist Fighting</option>
                    <option value="axe">Axe</option>
                    <option value="club">Club</option>
                    <option value="sword">Sword</option>
                </select>
            </div>
            <div style="flex:1;">
                <label>Valor do Skill</label>
                <input type="number" id="skillValue" value="163" step="1" min="0">
            </div>
        </div>
        <div class="param-item">
            <label>B√¥nus de Equipamento</label>
            <input type="number" id="bonusEquip" value="44" step="1">
        </div>
        <div class="param-item">
            <label>B√¥nus Diversos (combat tactics, etc.)</label>
            <input type="number" id="bonusOutros" value="38" step="1">
        </div>
        <div class="param-item">
            <label>Dano Extra Auto (Shielding)</label>
            <input type="number" id="autoExtra" value="9" step="1">
        </div>
        <div class="param-item">
            <label>Chance Cr√≠tico (%)</label>
            <input type="number" id="critChance" value="10" step="0.1" min="0" max="100">
        </div>
        <div class="param-item">
            <label>Dano Cr√≠tico Extra (%)</label>
            <input type="number" id="critDamage" value="57.5" step="0.1">
        </div>
        <div class="param-item">
            <label>Life Leech Base (%)</label>
            <input type="number" id="lifeLeech" value="50.75" step="0.01">
        </div>
        <div class="param-item">
            <label>Mana Leech Base (%)</label>
            <input type="number" id="manaLeech" value="16.25" step="0.01">
        </div>
        <div class="param-item">
            <label>Ataques por minuto</label>
            <input type="number" id="attacksPerMin" value="30" step="1">
        </div>
    </div>

    <div style="display: flex; align-items: center; gap: 15px;">
        <button id="calcAvgBtn">üìä Calcular Dano M√©dio</button>
        <span id="avgResult" class="result-box" style="flex:1; margin:0;">Clique para calcular</span>
    </div>

    <!-- Tabela de monstros da hunt atual -->
    <h2>üëæ Monstros da Hunt</h2>
    <div style="margin-bottom: 10px;">
        <button id="addRowBtn">‚ûï Adicionar Monstro</button>
        <button id="removeRowBtn">‚ûñ Remover √öltimo</button>
        <button id="calcTotalBtn">üî• Calcular Totais</button>
        <span style="margin-left: 20px; color:#aaa;">(Dados salvos automaticamente)</span>
    </div>

    <table id="monsterTable">
        <thead>
            <tr>
                <th>Nome</th>
                <th>Qtd/h</th>
                <th>Vida</th>
                <th>Fraqueza</th>
                <th>Major Charm</th>
                <th>N√≠vel</th>
                <th>Minor Charm (Leech)</th>
                <th>N√≠vel</th>
                <th>Dano Major</th>
                <th>Dano Minor</th>
                <th>Total/h (Mob)</th>
            </tr>
        </thead>
        <tbody id="tableBody">
            <!-- Linhas ser√£o inseridas via JavaScript -->
        </tbody>
    </table>

    <!-- Resultado total com sustain -->
    <div class="total-footer" id="totalResult">
        Dano F√≠sico/h: 0 | Dano Major/h: 0 | Dano Minor/h: 0 | Dano Total/h: 0<br>
        Life Leech/h: 0 (base) + 0 (charms) = 0 | Mana Leech/h: 0 (base) + 0 (charms) = 0
    </div>

    <!-- Cr√©ditos -->
    <div class="credits">Criado por Cedine Rush ¬∑ Vers√£o Corrigida (Classes CSS)</div>
</div>

<script>
    (function() {
        // ----- Elementos do DOM -----
        const levelInput = document.getElementById('level');
        const skillTypeSelect = document.getElementById('skillType');
        const skillValueInput = document.getElementById('skillValue');
        const bonusEquipInput = document.getElementById('bonusEquip');
        const bonusOutrosInput = document.getElementById('bonusOutros');
        const autoExtraInput = document.getElementById('autoExtra');
        const critChanceInput = document.getElementById('critChance');
        const critDamageInput = document.getElementById('critDamage');
        const lifeLeechInput = document.getElementById('lifeLeech');
        const manaLeechInput = document.getElementById('manaLeech');
        const attacksPerMinInput = document.getElementById('attacksPerMin');
        const calcAvgBtn = document.getElementById('calcAvgBtn');
        const avgResult = document.getElementById('avgResult');
        const tableBody = document.getElementById('tableBody');
        const addRowBtn = document.getElementById('addRowBtn');
        const removeRowBtn = document.getElementById('removeRowBtn');
        const calcTotalBtn = document.getElementById('calcTotalBtn');
        const totalResult = document.getElementById('totalResult');
        const huntSelect = document.getElementById('huntSelect');
        const newHuntBtn = document.getElementById('newHuntBtn');
        const renameHuntBtn = document.getElementById('renameHuntBtn');
        const deleteHuntBtn = document.getElementById('deleteHuntBtn');
        const adminIndicator = document.getElementById('adminIndicator');

        // ----- Formata√ß√£o de n√∫meros (duas casas decimais, ponto como separador de milhar) -----
        function formatNumber(value) {
            if (value === null || isNaN(value)) return '0,00';
            let parts = value.toFixed(2).split('.');
            let integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, '.');
            return integerPart + ',' + parts[1];
        }

        // ----- Verificar se √© admin (par√¢metro ?admin=true na URL) -----
        const urlParams = new URLSearchParams(window.location.search);
        const isAdmin = urlParams.get('admin') === 'true';
        if (isAdmin) {
            deleteHuntBtn.style.display = 'inline-block';
            adminIndicator.textContent = 'üîì Modo administrador ativo';
        } else {
            deleteHuntBtn.style.display = 'none';
            adminIndicator.textContent = '';
        }

        // ----- Estrutura de dados -----
        let hunts = [];
        let currentHuntId = null;
        const STORAGE_KEY = 'tibiaDamageHunts';

        // ----- Multiplicadores de Major Charms (causam dano) -----
        // A op√ß√£o "Normal" agora tem multiplicador 0 (n√£o causa dano)
        const MAJOR_MULTIPLIERS = {
            'normal': { 1: 0, 2: 0, 3: 0 },
            'low blow': { 1: 0.08, 2: 0.08, 3: 0.08 },
            'savage blow': { 1: 0.4, 2: 0.4, 3: 0.4 },
            'divine wrath': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'zap': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'freeze': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'curse': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'enflame': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'poison': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'wound': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'dodge': { 1: 0, 2: 0, 3: 0 },
            'parry': { 1: 0.25, 2: 0.25, 3: 0.25 },
            'gut': { 1: 0.10, 2: 0.12, 3: 0.14 },
            'adrenaline burst': { 1: 0, 2: 0, 3: 0 },
            'momentum': { 1: 0, 2: 0, 3: 0 },
            'vampirism': { 1: 0, 2: 0, 3: 0 },
            'venom': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'scorch': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'frost': { 1: 0.05, 2: 0.06, 3: 0.07 }
        };

        // ----- Multiplicadores dos Minor Charms (incluindo "Nenhum") -----
        const MINOR_MULTIPLIERS = {
            'nenhum': { 1: 0, 2: 0, 3: 0 },
            'vampiric embrace': { 1: 0.016, 2: 0.024, 3: 0.032 },
            'void\'s call': { 1: 0.008, 2: 0.012, 3: 0.016 },
            'void inversion': { 1: 0, 2: 0, 3: 0 }
        };

        // ----- Listas para os selects -----
        const MAJOR_OPTIONS = [
            'Normal', 'Low Blow', 'Savage Blow',
            'Divine Wrath', 'Zap', 'Freeze',
            'Curse', 'Enflame', 'Poison', 'Wound',
            'Dodge', 'Parry', 'Gut',
            'Adrenaline Burst', 'Momentum', 'Vampirism',
            'Venom', 'Scorch', 'Frost'
        ];

        const MINOR_OPTIONS = [
            'Nenhum',
            'Vampiric Embrace',
            'Void\'s Call',
            'Void Inversion'
        ];

        // ----- Fun√ß√µes para obter multiplicadores -----
        function getMajorMultiplier(type, level) {
            const key = (type || 'normal').toLowerCase().trim();
            const lvl = parseInt(level) || 1;
            return MAJOR_MULTIPLIERS[key]?.[lvl] || 0;
        }

        function getMinorMultiplier(type, level) {
            const key = (type || 'nenhum').toLowerCase().trim();
            const lvl = parseInt(level) || 1;
            return MINOR_MULTIPLIERS[key]?.[lvl] || 0;
        }

        // ----- C√°lculo do ataque base considerando o tipo de skill -----
        function calculateAttackBase() {
            const level = parseFloat(levelInput.value) || 107;
            const skillType = skillTypeSelect.value;
            const skillValue = parseFloat(skillValueInput.value) || 0;
            const bonusEquip = parseFloat(bonusEquipInput.value) || 0;
            const bonusOutros = parseFloat(bonusOutrosInput.value) || 0;
            
            const flatBonus = Math.round(level * 0.95);
            
            let skillContribution = 0;
            
            switch(skillType) {
                case 'distance':
                case 'fist':
                case 'axe':
                case 'club':
                case 'sword':
                    skillContribution = skillValue;
                    break;
                case 'magic':
                    skillContribution = Math.round(skillValue * 0.6);
                    break;
                default:
                    skillContribution = skillValue;
            }
            
            return flatBonus + skillContribution + bonusEquip + bonusOutros;
        }

        // ----- Utilit√°rios -----
        function generateId() {
            return Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        // ----- Persist√™ncia -----
        function loadFromStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    hunts = data.hunts || [];
                    currentHuntId = data.currentHuntId || (hunts.length > 0 ? hunts[0].id : null);
                } catch (e) {
                    console.error('Erro ao carregar dados', e);
                    resetToExamples();
                }
            } else {
                resetToExamples();
            }
            hunts.forEach(h => {
                if (!h.monsters) h.monsters = [];
                h.monsters.forEach(m => {
                    if (!m.majorType) m.majorType = 'Normal';
                    if (!m.majorLevel) m.majorLevel = 1;
                    if (!m.minorType) m.minorType = 'Nenhum';
                    if (!m.minorLevel) m.minorLevel = 1;
                });
            });
            if (hunts.length === 0) resetToExamples();
            if (!currentHuntId || !hunts.find(h => h.id === currentHuntId)) {
                if (hunts.length > 0) currentHuntId = hunts[0].id;
            }
        }

        function resetToExamples() {
            hunts = [
                {
                    id: generateId(),
                    name: 'Bulltaur Lair',
                    monsters: [
                        { name: 'Bulltaur Alchemist', qty: 614, hp: 5960, weakness: 1.2, majorType: 'Normal', majorLevel: 1, minorType: 'Vampiric Embrace', minorLevel: 2 },
                        { name: 'Bulltaur Brute', qty: 607, hp: 6560, weakness: 1.1, majorType: 'Divine Wrath', majorLevel: 2, minorType: 'Void\'s Call', minorLevel: 1 },
                        { name: 'Bulltaur Forgepriest', qty: 396, hp: 6840, weakness: 1.1, majorType: 'Freeze', majorLevel: 3, minorType: 'Nenhum', minorLevel: 1 }
                    ]
                },
                {
                    id: generateId(),
                    name: 'Goannas',
                    monsters: [
                        { name: 'Adult Goanna', qty: 359, hp: 8300, weakness: 1.2, majorType: 'Zap', majorLevel: 2, minorType: 'Vampiric Embrace', minorLevel: 1 },
                        { name: 'Manticore', qty: 340, hp: 6700, weakness: 1.2, majorType: 'Freeze', majorLevel: 1, minorType: 'Void\'s Call', minorLevel: 3 },
                        { name: 'Young Goanna', qty: 319, hp: 6944, weakness: 1.2, majorType: 'Zap', majorLevel: 2, minorType: 'Void Inversion', minorLevel: 2 },
                        { name: 'Feral Sphinx', qty: 292, hp: 9800, weakness: 1.15, majorType: 'Freeze', majorLevel: 3, minorType: 'Nenhum', minorLevel: 1 }
                    ]
                }
            ];
            currentHuntId = hunts[0].id;
        }

        function saveToStorage() {
            const data = { hunts, currentHuntId };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        function renderHuntSelect() {
            huntSelect.innerHTML = '';
            hunts.forEach(h => {
                const option = document.createElement('option');
                option.value = h.id;
                option.textContent = h.name;
                if (h.id === currentHuntId) option.selected = true;
                huntSelect.appendChild(option);
            });
        }

        function getCurrentHunt() {
            return hunts.find(h => h.id === currentHuntId) || null;
        }

        function getCurrentMonsters() {
            const hunt = getCurrentHunt();
            return hunt ? hunt.monsters : [];
        }

        function setCurrentMonsters(monsters) {
            const hunt = getCurrentHunt();
            if (hunt) {
                hunt.monsters = monsters;
                saveToStorage();
            }
        }

        // ----- C√°lculos de dano -----
        function calculateMajorDamage(m) {
            const mult = getMajorMultiplier(m.majorType, m.majorLevel);
            return (m.hp || 0) * mult * (m.weakness || 1.0);
        }

        function calculateMinorDamage(m) {
            return 0;
        }

        // ----- Dano m√©dio por ataque -----
        function calcAverageDamage() {
            const attackBase = calculateAttackBase();
            const autoExtra = parseFloat(autoExtraInput.value) || 9;
            const baseDamage = attackBase + autoExtra;
            const critChance = parseFloat(critChanceInput.value) / 100;
            const critExtra = parseFloat(critDamageInput.value) / 100;
            const normal = baseDamage;
            const crit = baseDamage * (1 + critExtra);
            const avg = (1 - critChance) * normal + critChance * crit;
            const lifeLeech = avg * (parseFloat(lifeLeechInput.value) / 100);
            const manaLeech = avg * (parseFloat(manaLeechInput.value) / 100);
            
            const skillType = skillTypeSelect.options[skillTypeSelect.selectedIndex].text;
            avgResult.innerHTML = `Dano m√©dio/ataque: <strong>${formatNumber(avg)}</strong><br>` +
                                  `Life Leech (base): ${formatNumber(lifeLeech)} | Mana Leech (base): ${formatNumber(manaLeech)}<br>` +
                                  `(Skill: ${skillType} ${skillValueInput.value} ‚Üí contribui√ß√£o ${attackBase - Math.round(parseFloat(levelInput.value) * 0.95) - bonusEquipInput.valueAsNumber - bonusOutrosInput.valueAsNumber})`;
            return { avg, lifeLeech, manaLeech, baseDamage };
        }

        calcAvgBtn.addEventListener('click', calcAverageDamage);

        // ----- Calcular totais por hora e sustain com charms -----
        calcTotalBtn.addEventListener('click', () => {
            const avgData = calcAverageDamage();
            const attacksPerHour = parseFloat(attacksPerMinInput.value) * 60;
            const physDamage = avgData.avg * attacksPerHour;

            const monsters = getCurrentMonsters();
            let majorTotal = 0;
            let lifeLeechBonusTotal = 0;
            let manaLeechBonusTotal = 0;

            monsters.forEach(m => {
                const majorDmg = calculateMajorDamage(m);
                const qty = m.qty || 0;
                const totalMobDmg = majorDmg * qty;
                majorTotal += totalMobDmg;

                const minorType = (m.minorType || 'nenhum').toLowerCase().trim();
                const minorLevel = parseInt(m.minorLevel) || 1;
                if (minorType.includes('vampiric')) {
                    const bonus = getMinorMultiplier('vampiric embrace', minorLevel);
                    lifeLeechBonusTotal += totalMobDmg * bonus;
                } else if (minorType.includes('void\'s') || minorType.includes('voids')) {
                    const bonus = getMinorMultiplier('void\'s call', minorLevel);
                    manaLeechBonusTotal += totalMobDmg * bonus;
                }
            });

            const totalDamage = physDamage + majorTotal;
            const lifeLeechBasePercent = parseFloat(lifeLeechInput.value) / 100;
            const manaLeechBasePercent = parseFloat(manaLeechInput.value) / 100;
            const lifeLeechBase = totalDamage * lifeLeechBasePercent;
            const manaLeechBase = totalDamage * manaLeechBasePercent;

            const lifeLeechTotal = lifeLeechBase + lifeLeechBonusTotal;
            const manaLeechTotal = manaLeechBase + manaLeechBonusTotal;

            totalResult.innerHTML = `Dano F√≠sico/h: <strong>${formatNumber(physDamage)}</strong> | ` +
                                    `Dano Major/h: <strong>${formatNumber(majorTotal)}</strong> | ` +
                                    `Dano Minor/h: <strong>0,00</strong> | ` +
                                    `Dano Total/h: <strong>${formatNumber(totalDamage)}</strong><br>` +
                                    `Life Leech/h: ${formatNumber(lifeLeechBase)} (base) + ${formatNumber(lifeLeechBonusTotal)} (charms) = <strong>${formatNumber(lifeLeechTotal)}</strong><br>` +
                                    `Mana Leech/h: ${formatNumber(manaLeechBase)} (base) + ${formatNumber(manaLeechBonusTotal)} (charms) = <strong>${formatNumber(manaLeechTotal)}</strong>`;
        });

        // ----- Renderizar tabela -----
        function renderTable() {
            const monsters = getCurrentMonsters();
            tableBody.innerHTML = '';
            monsters.forEach((m, index) => {
                const row = document.createElement('tr');

                // Nome
                const tdName = document.createElement('td');
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = m.name || '';
                nameInput.dataset.index = index;
                nameInput.dataset.field = 'name';
                nameInput.addEventListener('input', handleInputChange);
                tdName.appendChild(nameInput);
                row.appendChild(tdName);

                // Quantidade
                const tdQty = document.createElement('td');
                const qtyInput = document.createElement('input');
                qtyInput.type = 'number';
                qtyInput.value = m.qty || 0;
                qtyInput.step = 1;
                qtyInput.dataset.index = index;
                qtyInput.dataset.field = 'qty';
                qtyInput.addEventListener('input', handleInputChange);
                tdQty.appendChild(qtyInput);
                row.appendChild(tdQty);

                // Vida
                const tdHp = document.createElement('td');
                const hpInput = document.createElement('input');
                hpInput.type = 'number';
                hpInput.value = m.hp || 0;
                hpInput.step = 1;
                hpInput.dataset.index = index;
                hpInput.dataset.field = 'hp';
                hpInput.addEventListener('input', handleInputChange);
                tdHp.appendChild(hpInput);
                row.appendChild(tdHp);

                // Fraqueza
                const tdWeak = document.createElement('td');
                const weakInput = document.createElement('input');
                weakInput.type = 'number';
                weakInput.value = m.weakness || 1.0;
                weakInput.step = 0.01;
                weakInput.dataset.index = index;
                weakInput.dataset.field = 'weakness';
                weakInput.addEventListener('input', handleInputChange);
                tdWeak.appendChild(weakInput);
                row.appendChild(tdWeak);

                // Major Charm
                const tdMajor = document.createElement('td');
                const majorSelect = document.createElement('select');
                majorSelect.dataset.index = index;
                majorSelect.dataset.field = 'majorType';
                MAJOR_OPTIONS.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt;
                    if (m.majorType === opt) option.selected = true;
                    majorSelect.appendChild(option);
                });
                majorSelect.addEventListener('change', handleInputChange);
                tdMajor.appendChild(majorSelect);
                row.appendChild(tdMajor);

                // Major Level
                const tdMajorLevel = document.createElement('td');
                const majorLevelSelect = document.createElement('select');
                majorLevelSelect.dataset.index = index;
                majorLevelSelect.dataset.field = 'majorLevel';
                for (let lvl = 1; lvl <= 3; lvl++) {
                    const option = document.createElement('option');
                    option.value = lvl;
                    option.textContent = lvl;
                    if (m.majorLevel == lvl) option.selected = true;
                    majorLevelSelect.appendChild(option);
                }
                majorLevelSelect.addEventListener('change', handleInputChange);
                tdMajorLevel.appendChild(majorLevelSelect);
                row.appendChild(tdMajorLevel);

                // Minor Charm (Leech)
                const tdMinor = document.createElement('td');
                const minorSelect = document.createElement('select');
                minorSelect.dataset.index = index;
                minorSelect.dataset.field = 'minorType';
                MINOR_OPTIONS.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt;
                    if (m.minorType === opt) option.selected = true;
                    minorSelect.appendChild(option);
                });
                minorSelect.addEventListener('change', handleInputChange);
                tdMinor.appendChild(minorSelect);
                row.appendChild(tdMinor);

                // Minor Level
                const tdMinorLevel = document.createElement('td');
                const minorLevelSelect = document.createElement('select');
                minorLevelSelect.dataset.index = index;
                minorLevelSelect.dataset.field = 'minorLevel';
                for (let lvl = 1; lvl <= 3; lvl++) {
                    const option = document.createElement('option');
                    option.value = lvl;
                    option.textContent = lvl;
                    if (m.minorLevel == lvl) option.selected = true;
                    minorLevelSelect.appendChild(option);
                }
                minorLevelSelect.addEventListener('change', handleInputChange);
                tdMinorLevel.appendChild(minorLevelSelect);
                row.appendChild(tdMinorLevel);

                // Dano Major (com classe para atualiza√ß√£o)
                const tdDmgMajor = document.createElement('td');
                tdDmgMajor.className = 'dmg-major';
                tdDmgMajor.textContent = formatNumber(calculateMajorDamage(m));
                row.appendChild(tdDmgMajor);

                // Dano Minor (sempre 0)
                const tdDmgMinor = document.createElement('td');
                tdDmgMinor.className = 'dmg-minor';
                tdDmgMinor.textContent = '0,00';
                row.appendChild(tdDmgMinor);

                // Total/h (com classe para atualiza√ß√£o)
                const tdTotal = document.createElement('td');
                tdTotal.className = 'total-mob';
                const totalPerMob = calculateMajorDamage(m) * (m.qty || 0);
                tdTotal.textContent = formatNumber(totalPerMob);
                row.appendChild(tdTotal);

                tableBody.appendChild(row);
            });
        }

        // ----- Atualiza os campos de dano na tabela usando as classes CSS -----
        function updateDamageDisplays() {
            const monsters = getCurrentMonsters();
            const rows = tableBody.querySelectorAll('tr');
            rows.forEach((row, index) => {
                const mob = monsters[index];
                if (!mob) return;
                const majorDmg = calculateMajorDamage(mob);
                const totalPerMob = majorDmg * (mob.qty || 0);
                const tdMajor = row.querySelector('.dmg-major');
                const tdTotal = row.querySelector('.total-mob');
                if (tdMajor) tdMajor.textContent = formatNumber(majorDmg);
                if (tdTotal) tdTotal.textContent = formatNumber(totalPerMob);
                // Dano Minor permanece 0, n√£o precisa atualizar
            });
        }

        // ----- Handler para quando um input √© alterado -----
        function handleInputChange(e) {
            const input = e.target;
            const index = input.dataset.index;
            const field = input.dataset.field;
            let value = input.value;
            if (input.type === 'number' || input.tagName === 'SELECT') {
                if (field === 'qty' || field === 'hp' || field === 'weakness' || field === 'majorLevel' || field === 'minorLevel') {
                    value = parseFloat(value) || 0;
                } else {
                    value = input.value;
                }
                if (isNaN(value)) value = 0;
            }
            const monsters = getCurrentMonsters();
            if (monsters[index]) {
                monsters[index][field] = value;
                setCurrentMonsters(monsters);
                updateDamageDisplays(); // Atualiza a tabela imediatamente
            }
        }

        addRowBtn.addEventListener('click', () => {
            const monsters = getCurrentMonsters();
            monsters.push({
                name: 'Novo Monstro',
                qty: 100,
                hp: 5000,
                weakness: 1.0,
                majorType: 'Normal',
                majorLevel: 1,
                minorType: 'Nenhum',
                minorLevel: 1
            });
            setCurrentMonsters(monsters);
            renderTable();
        });

        removeRowBtn.addEventListener('click', () => {
            const monsters = getCurrentMonsters();
            if (monsters.length > 0) {
                monsters.pop();
                setCurrentMonsters(monsters);
                renderTable();
            }
        });

        function switchHunt(huntId) {
            if (!huntId) return;
            currentHuntId = huntId;
            saveToStorage();
            renderHuntSelect();
            renderTable();
        }

        huntSelect.addEventListener('change', (e) => {
            switchHunt(e.target.value);
        });

        newHuntBtn.addEventListener('click', () => {
            const name = prompt('Nome da nova hunt:');
            if (name && name.trim()) {
                const newHunt = {
                    id: generateId(),
                    name: name.trim(),
                    monsters: []
                };
                hunts.push(newHunt);
                currentHuntId = newHunt.id;
                saveToStorage();
                renderHuntSelect();
                renderTable();
            }
        });

        renameHuntBtn.addEventListener('click', () => {
            const hunt = getCurrentHunt();
            if (!hunt) return;
            const newName = prompt('Novo nome para a hunt:', hunt.name);
            if (newName && newName.trim()) {
                hunt.name = newName.trim();
                saveToStorage();
                renderHuntSelect();
            }
        });

        deleteHuntBtn.addEventListener('click', () => {
            if (!isAdmin) {
                alert('Apenas o administrador pode excluir hunts.');
                return;
            }
            if (hunts.length <= 1) {
                alert('N√£o √© poss√≠vel excluir a √∫nica hunt.');
                return;
            }
            const hunt = getCurrentHunt();
            if (!hunt) return;
            const confirm = window.confirm(`Deseja realmente excluir a hunt "${hunt.name}"?`);
            if (confirm) {
                hunts = hunts.filter(h => h.id !== hunt.id);
                currentHuntId = hunts[0].id;
                saveToStorage();
                renderHuntSelect();
                renderTable();
            }
        });

        // ----- Inicializa√ß√£o -----
        loadFromStorage();
        renderHuntSelect();
        renderTable();
        setTimeout(() => calcAverageDamage(), 100);
    })();
</script>
</body>
</html>
