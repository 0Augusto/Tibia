<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Dano - Tibia (Sustain Total)</title>
    <style>
        * { box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background: #1e1e2f; color: #ddd; max-width: 1200px; margin: 20px auto; padding: 0 20px; }
        h1, h2, h3 { color: #f0b87b; }
        .container { background: #2a2a3a; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); }
        .param-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .param-item { display: flex; flex-direction: column; }
        label { font-size: 0.9em; color: #aaa; margin-bottom: 3px; }
        input, select { background: #1e1e2f; border: 1px solid #3a3a4f; color: #fff; padding: 8px; border-radius: 5px; font-size: 1em; }
        input:focus, select:focus { outline: none; border-color: #f0b87b; }
        button { background: #f0b87b; color: #1e1e2f; border: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: 0.2s; margin-right: 10px; margin-bottom: 10px; }
        button:hover { background: #ffd966; }
        .result-box { background: #1e1e2f; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 5px solid #f0b87b; font-size: 1.1em; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; background: #1e1e2f; border-radius: 8px; overflow: hidden; }
        th { background: #3a3a4f; color: #f0b87b; padding: 10px; font-weight: 600; }
        td { padding: 8px; border-bottom: 1px solid #3a3a4f; }
        td input, td select { width: 100%; background: #252535; border: 1px solid #3a3a4f; }
        .action-btn { background: #4a4a6a; color: white; padding: 5px 10px; font-size: 0.9em; margin: 2px; }
        .action-btn:hover { background: #6a6a8a; }
        .total-footer { background: #3a3a4f; padding: 15px; border-radius: 8px; margin-top: 20px; font-size: 1.2em; text-align: center; }
        .credits { text-align: right; margin-top: 10px; color: #888; font-style: italic; }
        .hunt-bar { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .hunt-bar select { flex: 1; min-width: 200px; }
        .admin-note { font-size: 0.9em; color: #f0b87b; margin-left: 10px; }
    </style>
</head>
<body>
<div class="container">
    <h1>‚öîÔ∏è Calculadora de Dano - Tibia (Sustain Total)</h1>
    <p style="color:#ccc;">Level, skill, major e minor charms com n√≠veis. O sustain (life/mana leech) agora √© calculado sobre o dano total (f√≠sico + charms).</p>
    <p style="color:#aaa;">üîí A exclus√£o de hunts √© restrita ao administrador. Para ativar o modo admin, adicione <code>?admin=true</code> na URL.</p>

    <!-- Gerenciamento de Hunts -->
    <div class="hunt-bar">
        <label for="huntSelect" style="font-weight:bold;">Hunt atual:</label>
        <select id="huntSelect"></select>
        <button id="newHuntBtn">‚ûï Nova</button>
        <button id="renameHuntBtn">‚úèÔ∏è Renomear</button>
        <button id="deleteHuntBtn" style="display:none;">üóëÔ∏è Excluir (admin)</button>
        <span class="admin-note" id="adminIndicator"></span>
    </div>

    <!-- Par√¢metros do personagem com Level e Skill -->
    <div class="param-grid">
        <div class="param-item">
            <label>N√≠vel do Personagem</label>
            <input type="number" id="level" value="107" step="1" min="1">
        </div>
        <div class="param-item">
            <label>Skill de Dist√¢ncia</label>
            <input type="number" id="skill" value="163" step="1" min="0">
        </div>
        <div class="param-item">
            <label>B√¥nus de Equipamento</label>
            <input type="number" id="bonusEquip" value="44" step="1">
        </div>
        <div class="param-item">
            <label>B√¥nus Diversos (combat tactics, etc.)</label>
            <input type="number" id="bonusOutros" value="38" step="1">
        </div>
        <div class="param-item">
            <label>Dano Extra Auto (Shielding)</label>
            <input type="number" id="autoExtra" value="9" step="1">
        </div>
        <div class="param-item">
            <label>Chance Cr√≠tico (%)</label>
            <input type="number" id="critChance" value="10" step="0.1" min="0" max="100">
        </div>
        <div class="param-item">
            <label>Dano Cr√≠tico Extra (%)</label>
            <input type="number" id="critDamage" value="57.5" step="0.1">
        </div>
        <div class="param-item">
            <label>Life Leech (%)</label>
            <input type="number" id="lifeLeech" value="50.75" step="0.01">
        </div>
        <div class="param-item">
            <label>Mana Leech (%)</label>
            <input type="number" id="manaLeech" value="16.25" step="0.01">
        </div>
        <div class="param-item">
            <label>Ataques por minuto</label>
            <input type="number" id="attacksPerMin" value="30" step="1">
        </div>
    </div>

    <div style="display: flex; align-items: center; gap: 15px;">
        <button id="calcAvgBtn">üìä Calcular Dano M√©dio</button>
        <span id="avgResult" class="result-box" style="flex:1; margin:0;">Clique para calcular</span>
    </div>

    <!-- Tabela de monstros da hunt atual -->
    <h2>üëæ Monstros da Hunt</h2>
    <div style="margin-bottom: 10px;">
        <button id="addRowBtn">‚ûï Adicionar Monstro</button>
        <button id="removeRowBtn">‚ûñ Remover √öltimo</button>
        <button id="calcTotalBtn">üî• Calcular Totais</button>
        <span style="margin-left: 20px; color:#aaa;">(Dados salvos automaticamente)</span>
    </div>

    <table id="monsterTable">
        <thead>
            <tr>
                <th>Nome</th>
                <th>Qtd/h</th>
                <th>Vida</th>
                <th>Fraqueza (ex: 1.2)</th>
                <th>Tipo de Charm</th>
                <th>N√≠vel do Charm</th>
                <th>Dano por Mob</th>
                <th>Total/h</th>
            </tr>
        </thead>
        <tbody id="tableBody">
            <!-- Linhas ser√£o inseridas via JavaScript -->
        </tbody>
    </table>

    <!-- Resultado total com sustain -->
    <div class="total-footer" id="totalResult">
        Dano F√≠sico/h: 0 | Dano Charms/h: 0 | Dano Total/h: 0<br>
        Sustain: Life Leech/h: 0 | Mana Leech/h: 0
    </div>

    <!-- Cr√©ditos -->
    <div class="credits">Criado por Cedine Rush ¬∑ Vers√£o com Sustain Total</div>
</div>

<script>
    (function() {
        // ----- Elementos do DOM -----
        const levelInput = document.getElementById('level');
        const skillInput = document.getElementById('skill');
        const bonusEquipInput = document.getElementById('bonusEquip');
        const bonusOutrosInput = document.getElementById('bonusOutros');
        const autoExtraInput = document.getElementById('autoExtra');
        const critChanceInput = document.getElementById('critChance');
        const critDamageInput = document.getElementById('critDamage');
        const lifeLeechInput = document.getElementById('lifeLeech');
        const manaLeechInput = document.getElementById('manaLeech');
        const attacksPerMinInput = document.getElementById('attacksPerMin');
        const calcAvgBtn = document.getElementById('calcAvgBtn');
        const avgResult = document.getElementById('avgResult');
        const tableBody = document.getElementById('tableBody');
        const addRowBtn = document.getElementById('addRowBtn');
        const removeRowBtn = document.getElementById('removeRowBtn');
        const calcTotalBtn = document.getElementById('calcTotalBtn');
        const totalResult = document.getElementById('totalResult');
        const huntSelect = document.getElementById('huntSelect');
        const newHuntBtn = document.getElementById('newHuntBtn');
        const renameHuntBtn = document.getElementById('renameHuntBtn');
        const deleteHuntBtn = document.getElementById('deleteHuntBtn');
        const adminIndicator = document.getElementById('adminIndicator');

        // ----- Verificar se √© admin (par√¢metro ?admin=true na URL) -----
        const urlParams = new URLSearchParams(window.location.search);
        const isAdmin = urlParams.get('admin') === 'true';
        if (isAdmin) {
            deleteHuntBtn.style.display = 'inline-block';
            adminIndicator.textContent = 'üîì Modo administrador ativo';
        } else {
            deleteHuntBtn.style.display = 'none';
            adminIndicator.textContent = '';
        }

        // ----- Estrutura de dados -----
        let hunts = [];                // array de { id, name, monsters }
        let currentHuntId = null;

        const STORAGE_KEY = 'tibiaDamageHunts';

        // ----- Multiplicadores de charm por tipo e n√≠vel (percentuais exatos) -----
        const CHARM_MULTIPLIERS = {
            // Major Charms (base 5%/6%/7%)
            'normal': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'low blow': { 1: 0.08, 2: 0.08, 3: 0.08 }, // Low Blow fixo 8%
            'savage blow': { 1: 0.4, 2: 0.4, 3: 0.4 }, // Savage Blow fixo 40%
            
            // Outras Major Charms elementais
            'divine wrath': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'zap': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'freeze': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'curse': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'enflame': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'poison': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'wound': { 1: 0.05, 2: 0.06, 3: 0.07 },
            
            // Novas Major Charms
            'dodge': { 1: 0, 2: 0, 3: 0 }, // Dodge n√£o causa dano
            'parry': { 1: 0.25, 2: 0.25, 3: 0.25 }, // Parry 25% da vida (simplificado)
            'gut': { 1: 0.10, 2: 0.12, 3: 0.14 }, // Gut 10/12/14%
            'adrenaline burst': { 1: 0, 2: 0, 3: 0 }, // Sem dano
            'momentum': { 1: 0, 2: 0, 3: 0 }, // Sem dano
            'vampirism': { 1: 0, 2: 0, 3: 0 }, // Sem dano (apenas leech, n√£o incluso aqui)
            'venom': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'scorch': { 1: 0.05, 2: 0.06, 3: 0.07 },
            'frost': { 1: 0.05, 2: 0.06, 3: 0.07 },
            
            // Minor Charms (2%/3%/4%)
            'minor normal': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor zap': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor freeze': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor curse': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor enflame': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor poison': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor wound': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor divine wrath': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor venom': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor scorch': { 1: 0.02, 2: 0.03, 3: 0.04 },
            'minor frost': { 1: 0.02, 2: 0.03, 3: 0.04 }
        };

        // ----- Fun√ß√£o para obter o multiplicador correto -----
        function getCharmMultiplier(charmType, level) {
            const key = (charmType || 'normal').toLowerCase().trim();
            const levelNum = parseInt(level) || 1;
            
            if (CHARM_MULTIPLIERS[key]) {
                return CHARM_MULTIPLIERS[key][levelNum] || CHARM_MULTIPLIERS[key][1] || 0;
            }
            
            // Fallback para charms desconhecidos
            return 0.05;
        }

        // ----- Lista completa de charms para o select (ordenada) -----
        const CHARM_OPTIONS = [
            // Major Charms
            'Normal', 'Low Blow', 'Savage Blow',
            'Divine Wrath', 'Zap', 'Freeze',
            'Curse', 'Enflame', 'Poison', 'Wound',
            'Dodge', 'Parry', 'Gut', 
            'Adrenaline Burst', 'Momentum', 'Vampirism',
            'Venom', 'Scorch', 'Frost',
            
            // Minor Charms
            'Minor Normal', 'Minor Zap', 'Minor Freeze',
            'Minor Curse', 'Minor Enflame', 'Minor Poison', 'Minor Wound',
            'Minor Divine Wrath', 'Minor Venom', 'Minor Scorch', 'Minor Frost'
        ];

        // ----- Utilit√°rios -----
        function generateId() {
            return Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        // ----- Persist√™ncia -----
        function loadFromStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    hunts = data.hunts || [];
                    currentHuntId = data.currentHuntId || (hunts.length > 0 ? hunts[0].id : null);
                } catch (e) {
                    console.error('Erro ao carregar dados', e);
                    resetToExamples();
                }
            } else {
                resetToExamples();
            }
            // Garantir que cada hunt tenha um array de monsters e que cada monstro tenha n√≠vel de charm
            hunts.forEach(h => {
                if (!h.monsters) h.monsters = [];
                h.monsters.forEach(m => {
                    if (!m.charmLevel) m.charmLevel = 1;
                    if (!m.charmType) m.charmType = 'Normal';
                });
            });
            if (hunts.length === 0) resetToExamples();
            if (!currentHuntId || !hunts.find(h => h.id === currentHuntId)) {
                if (hunts.length > 0) currentHuntId = hunts[0].id;
            }
        }

        function resetToExamples() {
            // Cria hunts de exemplo com diversos charms e n√≠veis
            hunts = [
                {
                    id: generateId(),
                    name: 'Bulltaur Lair',
                    monsters: [
                        { name: 'Bulltaur Alchemist', qty: 614, hp: 5960, weakness: 1.2, charmType: 'Normal', charmLevel: 1 },
                        { name: 'Bulltaur Brute', qty: 607, hp: 6560, weakness: 1.1, charmType: 'Divine Wrath', charmLevel: 2 },
                        { name: 'Bulltaur Forgepriest', qty: 396, hp: 6840, weakness: 1.1, charmType: 'Freeze', charmLevel: 3 }
                    ]
                },
                {
                    id: generateId(),
                    name: 'Goannas',
                    monsters: [
                        { name: 'Adult Goanna', qty: 359, hp: 8300, weakness: 1.2, charmType: 'Zap', charmLevel: 2 },
                        { name: 'Manticore', qty: 340, hp: 6700, weakness: 1.2, charmType: 'Freeze', charmLevel: 1 },
                        { name: 'Young Goanna', qty: 319, hp: 6944, weakness: 1.2, charmType: 'Zap', charmLevel: 2 },
                        { name: 'Feral Sphinx', qty: 292, hp: 9800, weakness: 1.15, charmType: 'Freeze', charmLevel: 3 }
                    ]
                },
                {
                    id: generateId(),
                    name: 'Oramond',
                    monsters: [
                        { name: 'Dark Torturer', qty: 171, hp: 7350, weakness: 1.1, charmType: 'Divine Wrath', charmLevel: 1 },
                        { name: 'Grim Reaper', qty: 206, hp: 3900, weakness: 1.0, charmType: 'Zap', charmLevel: 2 },
                        { name: 'Destroyer', qty: 222, hp: 3700, weakness: 1.0, charmType: 'Low Blow', charmLevel: 1 },
                        { name: 'Hellspawn', qty: 269, hp: 3500, weakness: 1.0, charmType: 'Savage Blow', charmLevel: 1 }
                    ]
                },
                {
                    id: generateId(),
                    name: 'Teste Charms',
                    monsters: [
                        { name: 'Demon', qty: 50, hp: 10000, weakness: 1.0, charmType: 'Gut', charmLevel: 3 },
                        { name: 'Dragon', qty: 80, hp: 5000, weakness: 1.2, charmType: 'Minor Scorch', charmLevel: 2 },
                        { name: 'Orc', qty: 200, hp: 500, weakness: 1.0, charmType: 'Parry', charmLevel: 1 }
                    ]
                }
            ];
            currentHuntId = hunts[0].id;
        }

        function saveToStorage() {
            const data = { hunts, currentHuntId };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        // ----- Atualizar o combobox de hunts -----
        function renderHuntSelect() {
            huntSelect.innerHTML = '';
            hunts.forEach(h => {
                const option = document.createElement('option');
                option.value = h.id;
                option.textContent = h.name;
                if (h.id === currentHuntId) option.selected = true;
                huntSelect.appendChild(option);
            });
        }

        // ----- Obter a hunt atual -----
        function getCurrentHunt() {
            return hunts.find(h => h.id === currentHuntId) || null;
        }

        // ----- Obter os monstros da hunt atual -----
        function getCurrentMonsters() {
            const hunt = getCurrentHunt();
            return hunt ? hunt.monsters : [];
        }

        // ----- Salvar os monstros da hunt atual -----
        function setCurrentMonsters(monsters) {
            const hunt = getCurrentHunt();
            if (hunt) {
                hunt.monsters = monsters;
                saveToStorage();
            }
        }

        // ----- Calcular dano do charm baseado no monstro, tipo e n√≠vel -----
        function calculateCharmDamage(m) {
            const mult = getCharmMultiplier(m.charmType, m.charmLevel);
            // Charms que n√£o causam dano
            const nonDamageCharms = ['dodge', 'adrenaline burst', 'momentum', 'vampirism'];
            const charmLower = (m.charmType || '').toLowerCase();
            if (nonDamageCharms.includes(charmLower)) {
                return 0;
            }
            // Para Parry, usamos o multiplicador (j√° definido como 0.25)
            return (m.hp || 0) * mult * (m.weakness || 1.0);
        }

        // ----- Calcular o ataque base do personagem a partir de level, skill e b√¥nus -----
        function calculateAttackBase() {
            const level = parseFloat(levelInput.value) || 107;
            const skill = parseFloat(skillInput.value) || 163;
            const bonusEquip = parseFloat(bonusEquipInput.value) || 44;
            const bonusOutros = parseFloat(bonusOutrosInput.value) || 38;
            
            // Fator de convers√£o de level para flat damage: aproximadamente 0.95 por level
            const flatBonus = Math.round(level * 0.95);
            
            return flatBonus + skill + bonusEquip + bonusOutros;
        }

        // ----- Calcular dano m√©dio do personagem (incluindo cr√≠tico e leech) -----
        function calcAverageDamage() {
            const attackBase = calculateAttackBase();
            const autoExtra = parseFloat(autoExtraInput.value) || 9;
            const baseDamage = attackBase + autoExtra;
            
            const critChance = parseFloat(critChanceInput.value) / 100;
            const critExtra = parseFloat(critDamageInput.value) / 100;

            const normal = baseDamage;
            const crit = baseDamage * (1 + critExtra);
            const avg = (1 - critChance) * normal + critChance * crit;

            const lifeLeech = avg * (parseFloat(lifeLeechInput.value) / 100);
            const manaLeech = avg * (parseFloat(manaLeechInput.value) / 100);

            avgResult.innerHTML = `Dano m√©dio/ataque: <strong>${avg.toFixed(2)}</strong><br>` +
                                  `Life Leech: ${lifeLeech.toFixed(2)} | Mana Leech: ${manaLeech.toFixed(2)}<br>` +
                                  `(Attack base: ${attackBase} + auto ${autoExtra} = ${baseDamage})`;

            return { avg, lifeLeech, manaLeech, baseDamage };
        }

        calcAvgBtn.addEventListener('click', calcAverageDamage);

        // ----- Calcular totais por hora com sustain sobre dano total -----
        calcTotalBtn.addEventListener('click', () => {
            const avgData = calcAverageDamage();
            const attacksPerHour = parseFloat(attacksPerMinInput.value) * 60;
            const physDamage = avgData.avg * attacksPerHour;

            const monsters = getCurrentMonsters();
            let charmDamageTotal = 0;
            monsters.forEach(m => {
                charmDamageTotal += calculateCharmDamage(m) * (m.qty || 0);
            });

            const totalDamage = physDamage + charmDamageTotal;
            const lifeLeechPercent = parseFloat(lifeLeechInput.value) / 100;
            const manaLeechPercent = parseFloat(manaLeechInput.value) / 100;
            const totalLifeLeech = totalDamage * lifeLeechPercent;
            const totalManaLeech = totalDamage * manaLeechPercent;

            totalResult.innerHTML = `Dano F√≠sico/h: <strong>${physDamage.toFixed(0)}</strong> | ` +
                                    `Dano Charms/h: <strong>${charmDamageTotal.toFixed(0)}</strong> | ` +
                                    `Dano Total/h: <strong>${totalDamage.toFixed(0)}</strong><br>` +
                                    `Sustain: Life Leech/h: <strong>${totalLifeLeech.toFixed(0)}</strong> | Mana Leech/h: <strong>${totalManaLeech.toFixed(0)}</strong>`;
        });

        // ----- Renderizar tabela de monstros da hunt atual -----
        function renderTable() {
            const monsters = getCurrentMonsters();
            tableBody.innerHTML = '';
            monsters.forEach((m, index) => {
                const row = document.createElement('tr');

                // Nome
                const tdName = document.createElement('td');
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = m.name || '';
                nameInput.dataset.index = index;
                nameInput.dataset.field = 'name';
                nameInput.addEventListener('input', handleInputChange);
                tdName.appendChild(nameInput);
                row.appendChild(tdName);

                // Quantidade
                const tdQty = document.createElement('td');
                const qtyInput = document.createElement('input');
                qtyInput.type = 'number';
                qtyInput.value = m.qty || 0;
                qtyInput.step = 1;
                qtyInput.dataset.index = index;
                qtyInput.dataset.field = 'qty';
                qtyInput.addEventListener('input', handleInputChange);
                tdQty.appendChild(qtyInput);
                row.appendChild(tdQty);

                // Vida
                const tdHp = document.createElement('td');
                const hpInput = document.createElement('input');
                hpInput.type = 'number';
                hpInput.value = m.hp || 0;
                hpInput.step = 1;
                hpInput.dataset.index = index;
                hpInput.dataset.field = 'hp';
                hpInput.addEventListener('input', handleInputChange);
                tdHp.appendChild(hpInput);
                row.appendChild(tdHp);

                // Fraqueza
                const tdWeak = document.createElement('td');
                const weakInput = document.createElement('input');
                weakInput.type = 'number';
                weakInput.value = m.weakness || 1.0;
                weakInput.step = 0.01;
                weakInput.dataset.index = index;
                weakInput.dataset.field = 'weakness';
                weakInput.addEventListener('input', handleInputChange);
                tdWeak.appendChild(weakInput);
                row.appendChild(tdWeak);

                // Tipo de Charm
                const tdCharm = document.createElement('td');
                const charmSelect = document.createElement('select');
                charmSelect.dataset.index = index;
                charmSelect.dataset.field = 'charmType';
                
                CHARM_OPTIONS.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt;
                    if (m.charmType === opt) option.selected = true;
                    charmSelect.appendChild(option);
                });
                charmSelect.addEventListener('change', handleInputChange);
                tdCharm.appendChild(charmSelect);
                row.appendChild(tdCharm);

                // N√≠vel do Charm
                const tdCharmLevel = document.createElement('td');
                const levelSelect = document.createElement('select');
                levelSelect.dataset.index = index;
                levelSelect.dataset.field = 'charmLevel';
                for (let lvl = 1; lvl <= 3; lvl++) {
                    const option = document.createElement('option');
                    option.value = lvl;
                    option.textContent = `N√≠vel ${lvl}`;
                    if (m.charmLevel == lvl) option.selected = true;
                    levelSelect.appendChild(option);
                }
                levelSelect.addEventListener('change', handleInputChange);
                tdCharmLevel.appendChild(levelSelect);
                row.appendChild(tdCharmLevel);

                // Dano por Mob (calculado)
                const tdDmgMob = document.createElement('td');
                tdDmgMob.className = 'dmg-mob';
                tdDmgMob.textContent = calculateCharmDamage(m).toFixed(2);
                row.appendChild(tdDmgMob);

                // Total/h (calculado)
                const tdTotal = document.createElement('td');
                tdTotal.className = 'total-mob';
                tdTotal.textContent = (calculateCharmDamage(m) * (m.qty || 0)).toFixed(2);
                row.appendChild(tdTotal);

                tableBody.appendChild(row);
            });
        }

        // ----- Atualiza os campos de dano na tabela ap√≥s altera√ß√µes -----
        function updateDamageDisplays() {
            const monsters = getCurrentMonsters();
            const rows = tableBody.querySelectorAll('tr');
            rows.forEach((row, index) => {
                const mob = monsters[index];
                if (!mob) return;
                const dmgMob = calculateCharmDamage(mob);
                const totalMob = dmgMob * (mob.qty || 0);
                const tdDmg = row.querySelector('td:nth-child(7)');
                const tdTotal = row.querySelector('td:nth-child(8)');
                if (tdDmg) tdDmg.textContent = dmgMob.toFixed(2);
                if (tdTotal) tdTotal.textContent = totalMob.toFixed(2);
            });
        }

        // ----- Handler para quando um input √© alterado -----
        function handleInputChange(e) {
            const input = e.target;
            const index = input.dataset.index;
            const field = input.dataset.field;
            let value = input.value;
            if (input.type === 'number' || input.tagName === 'SELECT') {
                if (field === 'qty' || field === 'hp' || field === 'weakness' || field === 'charmLevel') {
                    value = parseFloat(value) || 0;
                } else if (field === 'charmType') {
                    value = input.value;
                }
                if (isNaN(value)) value = 0;
            }
            const monsters = getCurrentMonsters();
            if (monsters[index]) {
                monsters[index][field] = value;
                setCurrentMonsters(monsters);
                updateDamageDisplays();
            }
        }

        // ----- Adicionar nova linha √† hunt atual -----
        addRowBtn.addEventListener('click', () => {
            const monsters = getCurrentMonsters();
            monsters.push({
                name: 'Novo Monstro',
                qty: 100,
                hp: 5000,
                weakness: 1.0,
                charmType: 'Normal',
                charmLevel: 1
            });
            setCurrentMonsters(monsters);
            renderTable();
        });

        // ----- Remover √∫ltima linha da hunt atual -----
        removeRowBtn.addEventListener('click', () => {
            const monsters = getCurrentMonsters();
            if (monsters.length > 0) {
                monsters.pop();
                setCurrentMonsters(monsters);
                renderTable();
            }
        });

        // ----- Trocar de hunt -----
        function switchHunt(huntId) {
            if (!huntId) return;
            currentHuntId = huntId;
            saveToStorage();
            renderHuntSelect();
            renderTable();
        }

        huntSelect.addEventListener('change', (e) => {
            switchHunt(e.target.value);
        });

        // ----- Nova hunt (permitida para todos) -----
        newHuntBtn.addEventListener('click', () => {
            const name = prompt('Nome da nova hunt:');
            if (name && name.trim()) {
                const newHunt = {
                    id: generateId(),
                    name: name.trim(),
                    monsters: []
                };
                hunts.push(newHunt);
                currentHuntId = newHunt.id;
                saveToStorage();
                renderHuntSelect();
                renderTable();
            }
        });

        // ----- Renomear hunt atual (permitido para todos) -----
        renameHuntBtn.addEventListener('click', () => {
            const hunt = getCurrentHunt();
            if (!hunt) return;
            const newName = prompt('Novo nome para a hunt:', hunt.name);
            if (newName && newName.trim()) {
                hunt.name = newName.trim();
                saveToStorage();
                renderHuntSelect();
            }
        });

        // ----- Excluir hunt atual (apenas admin) -----
        deleteHuntBtn.addEventListener('click', () => {
            if (!isAdmin) {
                alert('Apenas o administrador pode excluir hunts.');
                return;
            }
            if (hunts.length <= 1) {
                alert('N√£o √© poss√≠vel excluir a √∫nica hunt.');
                return;
            }
            const hunt = getCurrentHunt();
            if (!hunt) return;
            const confirm = window.confirm(`Deseja realmente excluir a hunt "${hunt.name}"?`);
            if (confirm) {
                hunts = hunts.filter(h => h.id !== hunt.id);
                currentHuntId = hunts[0].id;
                saveToStorage();
                renderHuntSelect();
                renderTable();
            }
        });

        // ----- Inicializa√ß√£o -----
        loadFromStorage();
        renderHuntSelect();
        renderTable();
        // Calcular dano m√©dio inicial
        setTimeout(() => calcAverageDamage(), 100);
    })();
</script>
</body>
</html>
